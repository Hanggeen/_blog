{
  "content": [
    {
      "h1": "关于ETag的认识"
    },
    {
      "sub": "2016.06.02 | 广州 · 晴朗"
    },
    {
      "p": "文/总结于网络"
    },
    {
      "img": {
        "src": "1.png",
        "alt": "'图片'"
      }
    },
    {
      "p": "ETag是HTTP/1.1的一个和文件相关的标记"
    },
    {
      "p": "客户端请求一个页面（A）。"
    },
    {
      "p": "服务器返回页面A，并在给A加上一个ETag。 "
    },
    {
      "p": "客户端展现该页面，并将页面连同ETag一起缓存。"
    },
    {
      "p": "客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。"
    },
    {
      "p": "服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。"
    },
    {
      "h3":"请求流程"
    },
    {
      "p": "Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match.请求一个文件的流程可能如下："
    },
    {
      "p": "====第一次请求==="
    },
    {
      "p":"1.客户端发起 HTTP GET 请求一个文件；"
    },
    {
      "p":" 2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如'2e681a-6-5d044840')(假设服务器支持Etag生成和已经开启了Etag).状态码200"
    },
    {
      "p":"====第二次请求==="
    },
    {
      "p":"1.客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的2e681a-6-5d044840"
    },
    {
      "p":"2.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；。"
    },
    {
      "p":"流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办？"
    },
    {
      "p":"答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后，服务器才能返回304.(不要陷入到底使用谁的问题怪圈)"
    }
  ]
}